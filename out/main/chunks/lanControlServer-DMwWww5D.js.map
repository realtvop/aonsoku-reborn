{"version":3,"file":"lanControlServer-DMwWww5D.js","sources":["../../../node_modules/ws/lib/constants.js","../../../node_modules/ws/lib/buffer-util.js","../../../node_modules/ws/lib/permessage-deflate.js","../../../node_modules/ws/lib/limiter.js","../../../node_modules/ws/lib/validation.js","../../../node_modules/ws/lib/receiver.js","../../../node_modules/ws/lib/sender.js","../../../node_modules/ws/lib/extension.js","../../../node_modules/ws/lib/websocket.js","../../../node_modules/ws/lib/event-target.js","../../../node_modules/ws/lib/stream.js","../../../node_modules/ws/lib/websocket-server.js","../../../node_modules/ws/lib/subprotocol.js","../../../electron/main/core/lanControlTypes.ts","../../../electron/main/core/i18n.ts","../../../electron/main/core/lanControlServer.ts"],"sourcesContent":["'use strict';\n\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nconst hasBlob = typeof Blob !== 'undefined';\n\nif (hasBlob) BINARY_TYPES.push('blob');\n\nmodule.exports = {\n  BINARY_TYPES,\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  hasBlob,\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n","'use strict';\n\nconst { EMPTY_BUFFER } = require('./constants');\n\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) {\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = require('bufferutil');\n\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    };\n\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n","'use strict';\n\nconst zlib = require('zlib');\n\nconst bufferUtil = require('./buffer-util');\nconst Limiter = require('./limiter');\nconst { kStatusCode } = require('./constants');\n\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) {\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n      }\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n\n  //\n  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the\n  // fact that in Node.js versions prior to 13.10.0, the callback for\n  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing\n  // `zlib.reset()` ensures that either the callback is invoked or an error is\n  // emitted.\n  //\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n\n  if (this[kError]) {\n    this[kCallback](this[kError]);\n    return;\n  }\n\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n","'use strict';\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n","'use strict';\n\nconst { isUtf8 } = require('buffer');\n\nconst { hasBlob } = require('./constants');\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Determines whether a value is a `Blob`.\n *\n * @param {*} value The value to be tested\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n * @private\n */\nfunction isBlob(value) {\n  return (\n    hasBlob &&\n    typeof value === 'object' &&\n    typeof value.arrayBuffer === 'function' &&\n    typeof value.type === 'string' &&\n    typeof value.stream === 'function' &&\n    (value[Symbol.toStringTag] === 'Blob' ||\n      value[Symbol.toStringTag] === 'File')\n  );\n}\n\nmodule.exports = {\n  isBlob,\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\n\nif (isUtf8) {\n  module.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = require('utf-8-validate');\n\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n","'use strict';\n\nconst { Writable } = require('stream');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = require('./constants');\nconst { concat, toArrayBuffer, unmask } = require('./buffer-util');\nconst { isValidStatusCode, isValidUTF8 } = require('./validation');\n\nconst FastBuffer = Buffer[Symbol.species];\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._allowSynchronousEvents =\n      options.allowSynchronousEvents !== undefined\n        ? options.allowSynchronousEvents\n        : true;\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._errored = false;\n    this._loop = false;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(\n        buf.buffer,\n        buf.byteOffset + n,\n        buf.length - n\n      );\n\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(\n          buf.buffer,\n          buf.byteOffset + n,\n          buf.length - n\n        );\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64(cb);\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData(cb);\n          break;\n        case INFLATING:\n        case DEFER_EVENT:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    if (!this._errored) cb();\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      const error = this.createError(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n\n      cb(error);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      const error = this.createError(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (!this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        const error = this.createError(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (\n        this._payloadLength > 0x7d ||\n        (this._opcode === 0x08 && this._payloadLength === 1)\n      ) {\n        const error = this.createError(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    } else {\n      const error = this.createError(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        const error = this.createError(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n\n        cb(error);\n        return;\n      }\n    } else if (this._masked) {\n      const error = this.createError(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(cb) {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      const error = this.createError(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(cb) {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        const error = this.createError(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data, cb);\n      return;\n    }\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    this.dataMessage(cb);\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const error = this.createError(\n            RangeError,\n            'Max payload size exceeded',\n            false,\n            1009,\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._fragments.push(buf);\n      }\n\n      this.dataMessage(cb);\n      if (this._state === GET_INFO) this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(cb) {\n    if (!this._fin) {\n      this._state = GET_INFO;\n      return;\n    }\n\n    const messageLength = this._messageLength;\n    const fragments = this._fragments;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragmented = 0;\n    this._fragments = [];\n\n    if (this._opcode === 2) {\n      let data;\n\n      if (this._binaryType === 'nodebuffer') {\n        data = concat(fragments, messageLength);\n      } else if (this._binaryType === 'arraybuffer') {\n        data = toArrayBuffer(concat(fragments, messageLength));\n      } else if (this._binaryType === 'blob') {\n        data = new Blob(fragments);\n      } else {\n        data = fragments;\n      }\n\n      if (this._allowSynchronousEvents) {\n        this.emit('message', data, true);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', data, true);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    } else {\n      const buf = concat(fragments, messageLength);\n\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n        const error = this.createError(\n          Error,\n          'invalid UTF-8 sequence',\n          true,\n          1007,\n          'WS_ERR_INVALID_UTF8'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\n        this.emit('message', buf, false);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', buf, false);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data, cb) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this._loop = false;\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          const error = this.createError(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n\n          cb(error);\n          return;\n        }\n\n        const buf = new FastBuffer(\n          data.buffer,\n          data.byteOffset + 2,\n          data.length - 2\n        );\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          const error = this.createError(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._loop = false;\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n\n      this._state = GET_INFO;\n      return;\n    }\n\n    if (this._allowSynchronousEvents) {\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n      this._state = GET_INFO;\n    } else {\n      this._state = DEFER_EVENT;\n      setImmediate(() => {\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n        this._state = GET_INFO;\n        this.startLoop(cb);\n      });\n    }\n  }\n\n  /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n    this._loop = false;\n    this._errored = true;\n\n    const err = new ErrorCtor(\n      prefix ? `Invalid WebSocket frame: ${message}` : message\n    );\n\n    Error.captureStackTrace(err, this.createError);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n  }\n}\n\nmodule.exports = Receiver;\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */\n\n'use strict';\n\nconst { Duplex } = require('stream');\nconst { randomFillSync } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = require('./constants');\nconst { isBlob, isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\n\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._queue = [];\n    this._state = DEFAULT;\n    this.onerror = NOOP;\n    this[kWebSocket] = undefined;\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        if (randomPoolPointer === RANDOM_POOL_SIZE) {\n          /* istanbul ignore else  */\n          if (randomPool === undefined) {\n            //\n            // This is lazily initialized because server-sent frames must not\n            // be masked so it may never be used.\n            //\n            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n          }\n\n          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n          randomPoolPointer = 0;\n        }\n\n        mask[0] = randomPool[randomPoolPointer++];\n        mask[1] = randomPool[randomPoolPointer++];\n        mask[2] = randomPool[randomPoolPointer++];\n        mask[3] = randomPool[randomPoolPointer++];\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, false, options, cb]);\n      } else {\n        this.getBlobData(data, false, options, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, false, options, cb]);\n      } else {\n        this.getBlobData(data, false, options, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    const opts = {\n      [kByteLength]: byteLength,\n      fin: options.fin,\n      generateMask: this._generateMask,\n      mask: options.mask,\n      maskBuffer: this._maskBuffer,\n      opcode,\n      readOnly,\n      rsv1\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);\n      } else {\n        this.getBlobData(data, this._compress, opts, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n    } else {\n      this.dispatch(data, this._compress, opts, cb);\n    }\n  }\n\n  /**\n   * Gets the contents of a blob as binary data.\n   *\n   * @param {Blob} blob The blob\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     the data\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  getBlobData(blob, compress, options, cb) {\n    this._bufferedBytes += options[kByteLength];\n    this._state = GET_BLOB_DATA;\n\n    blob\n      .arrayBuffer()\n      .then((arrayBuffer) => {\n        if (this._socket.destroyed) {\n          const err = new Error(\n            'The socket was closed while the blob was being read'\n          );\n\n          //\n          // `callCallbacks` is called in the next tick to ensure that errors\n          // that might be thrown in the callbacks behave like errors thrown\n          // outside the promise chain.\n          //\n          process.nextTick(callCallbacks, this, err, cb);\n          return;\n        }\n\n        this._bufferedBytes -= options[kByteLength];\n        const data = toBuffer(arrayBuffer);\n\n        if (!compress) {\n          this._state = DEFAULT;\n          this.sendFrame(Sender.frame(data, options), cb);\n          this.dequeue();\n        } else {\n          this.dispatch(data, compress, options, cb);\n        }\n      })\n      .catch((err) => {\n        //\n        // `onError` is called in the next tick for the same reason that\n        // `callCallbacks` above is.\n        //\n        process.nextTick(onError, this, err, cb);\n      });\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._state = DEFLATING;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        callCallbacks(this, err, cb);\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._state = DEFAULT;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (this._state === DEFAULT && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {(Buffer | String)[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n/**\n * Calls queued callbacks with an error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error to call the callbacks with\n * @param {Function} [cb] The first callback\n * @private\n */\nfunction callCallbacks(sender, err, cb) {\n  if (typeof cb === 'function') cb(err);\n\n  for (let i = 0; i < sender._queue.length; i++) {\n    const params = sender._queue[i];\n    const callback = params[params.length - 1];\n\n    if (typeof callback === 'function') callback(err);\n  }\n}\n\n/**\n * Handles a `Sender` error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error\n * @param {Function} [cb] The first pending callback\n * @private\n */\nfunction onError(sender, err, cb) {\n  callCallbacks(sender, err, cb);\n  sender.onerror(err);\n}\n","'use strict';\n\nconst { tokenChars } = require('./validation');\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst { randomBytes, createHash } = require('crypto');\nconst { Duplex, Readable } = require('stream');\nconst { URL } = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst { isBlob } = require('./validation');\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = require('./event-target');\nconst { format, parse } = require('./extension');\nconst { toBuffer } = require('./buffer-util');\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._errorEmitted = false;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._autoPong = options.autoPong;\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n   * instead of \"blob\".\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      allowSynchronousEvents: options.allowSynchronousEvents,\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    const sender = new Sender(socket, this._extensions, options.generateMask);\n\n    this._receiver = receiver;\n    this._sender = sender;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    sender[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    sender.onerror = senderOnError;\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    setCloseTimer(this);\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    allowSynchronousEvents: true,\n    autoPong: true,\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  websocket._autoPong = opts.autoPong;\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n\n  websocket._url = parsedUrl.href;\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\n      '\"http:\", \"https:\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection =\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl\n        ? websocket._originalIpc\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalIpc\n          ? false\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const upgrade = res.headers.upgrade;\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      allowSynchronousEvents: opts.allowSynchronousEvents,\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  //\n  // The following assignment is practically useless and is done only for\n  // consistency.\n  //\n  websocket._errorEmitted = true;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The `Sender` error event handler.\n *\n * @param {Error} The error\n * @private\n */\nfunction senderOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket.readyState === WebSocket.CLOSED) return;\n  if (websocket.readyState === WebSocket.OPEN) {\n    websocket._readyState = WebSocket.CLOSING;\n    setCloseTimer(websocket);\n  }\n\n  //\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\n  // peer to finish sending queued data. There is no need to set a timer here\n  // because `CLOSING` means that it is already set or not needed.\n  //\n  this._socket.end();\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * Set a timer to destroy the underlying raw socket of a WebSocket.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @private\n */\nfunction setCloseTimer(websocket) {\n  websocket._closeTimer = setTimeout(\n    websocket._socket.destroy.bind(websocket._socket),\n    closeTimeout\n  );\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n","'use strict';\n\nconst { kForOnEventAttribute, kListener } = require('./constants');\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (\n        !options[kForOnEventAttribute] &&\n        listener[kListener] === handler &&\n        !listener[kForOnEventAttribute]\n      ) {\n        return;\n      }\n    }\n\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^WebSocket$\" }] */\n'use strict';\n\nconst WebSocket = require('./websocket');\nconst { Duplex } = require('stream');\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst http = require('http');\nconst { Duplex } = require('stream');\nconst { createHash } = require('crypto');\n\nconst extension = require('./extension');\nconst PerMessageDeflate = require('./permessage-deflate');\nconst subprotocol = require('./subprotocol');\nconst WebSocket = require('./websocket');\nconst { GUID, kWebSocket } = require('./constants');\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      allowSynchronousEvents: true,\n      autoPong: true,\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (key === undefined || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 13 && version !== 8) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {\n        'Sec-WebSocket-Version': '13, 8'\n      });\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null, undefined, this.options);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @param {Object} [headers] The HTTP response headers\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(\n  server,\n  req,\n  socket,\n  code,\n  message,\n  headers\n) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message, headers);\n  }\n}\n","'use strict';\n\nconst { tokenChars } = require('./validation');\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n","/**\n * LAN Control types and interfaces\n */\n\nexport interface LanControlConfig {\n  enabled: boolean;\n  port: number;\n  password: string;\n  allowNavidromeAuth: boolean;\n}\n\nexport enum LanControlMessageType {\n  // Authentication\n  AUTH_REQUEST = \"auth_request\",\n  AUTH_RESPONSE = \"auth_response\",\n\n  // Player control\n  PLAY_PAUSE = \"play_pause\",\n  PLAY = \"play\",\n  PAUSE = \"pause\",\n  NEXT = \"next\",\n  PREVIOUS = \"previous\",\n  SEEK = \"seek\",\n  SET_VOLUME = \"set_volume\",\n\n  // Playlist control\n  PLAY_SONG = \"play_song\",\n  PLAY_ALBUM = \"play_album\",\n  PLAY_PLAYLIST = \"play_playlist\",\n  PLAY_ALBUM_FROM_INDEX = \"play_album_from_index\",\n  PLAY_PLAYLIST_FROM_INDEX = \"play_playlist_from_index\",\n  ADD_TO_QUEUE = \"add_to_queue\",\n  CLEAR_QUEUE = \"clear_queue\",\n\n  // Shuffle & Repeat\n  TOGGLE_SHUFFLE = \"toggle_shuffle\",\n  TOGGLE_REPEAT = \"toggle_repeat\",\n  SET_SHUFFLE = \"set_shuffle\",\n  SET_REPEAT = \"set_repeat\",\n\n  // State requests\n  GET_STATE = \"get_state\",\n  GET_QUEUE = \"get_queue\",\n  GET_CURRENT_SONG = \"get_current_song\",\n\n  // State updates (server to client)\n  STATE_UPDATE = \"state_update\",\n  QUEUE_UPDATE = \"queue_update\",\n  CURRENT_SONG_UPDATE = \"current_song_update\",\n\n  // Error\n  ERROR = \"error\",\n}\n\nexport interface LanControlMessage {\n  type: LanControlMessageType;\n  data?: unknown;\n  timestamp?: number;\n}\n\nexport interface AuthRequestData {\n  username?: string;\n  password: string;\n  authType: \"navidrome\" | \"lan\";\n}\n\nexport interface AuthResponseData {\n  success: boolean;\n  message?: string;\n  deviceInfo?: {\n    name: string;\n    version: string;\n  };\n}\n\nexport interface PlayerStateData {\n  isPlaying: boolean;\n  currentTime: number;\n  duration: number;\n  volume: number;\n  isShuffle: boolean;\n  repeatMode: \"off\" | \"one\" | \"all\";\n  hasPrevious: boolean;\n  hasNext: boolean;\n}\n\nexport interface CurrentSongData {\n  id: string;\n  title: string;\n  artist: string;\n  album: string;\n  coverArt?: string;\n  duration: number;\n}\n\nexport interface QueueData {\n  songs: CurrentSongData[];\n  currentIndex: number;\n}\n\nexport interface SeekData {\n  time: number;\n}\n\nexport interface VolumeData {\n  volume: number;\n}\n\nexport interface PlaySongData {\n  songId: string;\n}\n\nexport interface PlayAlbumData {\n  albumId: string;\n  songIndex?: number;\n}\n\nexport interface PlayPlaylistData {\n  playlistId: string;\n  songIndex?: number;\n}\n\nexport interface AddToQueueData {\n  songIds: string[];\n}\n\nexport interface SetShuffleData {\n  enabled: boolean;\n}\n\nexport interface SetRepeatData {\n  mode: \"off\" | \"one\" | \"all\";\n}\n\nexport interface ErrorData {\n  message: string;\n  code?: string;\n}\n\nexport interface LanControlServerInfo {\n  running: boolean;\n  port: number;\n  address?: string;\n  addresses?: string[];\n  error?: string;\n}\n","export const i18n = {\n  en: {\n    server: {\n      alreadyRunning: \"Server already running\",\n      healthStatus: \"ok\",\n    },\n    auth: {\n      timeout: \"Authentication timeout\",\n      success: \"Authentication successful\",\n      failed: \"Authentication failed\",\n      notAuthenticated: \"Not authenticated\",\n    },\n    error: {\n      invalidMessage: \"Invalid message format\",\n      mainWindowUnavailable: \"Main window not available\",\n      notFound: \"Not Found\",\n    },\n    settings: {\n      desktop: {\n        lanControl: {\n          enable: \"Enable LAN Control\",\n          port: \"Port\",\n          password: \"Password\",\n          allowNavidromeAuth: \"Allow Navidrome Authentication\",\n        },\n      },\n    },\n  },\n  zh: {\n    server: {\n      alreadyRunning: \"\",\n      healthStatus: \"\",\n    },\n    auth: {\n      timeout: \"\",\n      success: \"\",\n      failed: \"\",\n      notAuthenticated: \"\",\n    },\n    error: {\n      invalidMessage: \"\",\n      mainWindowUnavailable: \"\",\n      notFound: \"\",\n    },\n    settings: {\n      desktop: {\n        lanControl: {\n          enable: \"\",\n          port: \"\",\n          password: \"\",\n          allowNavidromeAuth: \" Navidrome \",\n        },\n      },\n    },\n  },\n};\n","import type { BrowserWindow } from \"electron\";\nimport type { IncomingMessage } from \"node:http\";\nimport { createServer, type Server as HttpServer } from \"node:http\";\nimport path from \"node:path\";\nimport type { Express, Request, Response } from \"express\";\nimport { WebSocket, WebSocketServer } from \"ws\";\nimport {\n  LanControlConfig,\n  LanControlMessage,\n  LanControlMessageType,\n  AuthRequestData,\n  AuthResponseData,\n  PlayerStateData,\n  CurrentSongData,\n  QueueData,\n} from \"./lanControlTypes\";\nimport { i18n } from \"./i18n\";\n\n// These will be dynamically imported when server starts\n// type Express = any\n// type Request = any\n// type Response = any\n// type WebSocketServer = any\n// type WebSocket = any\n\n// const __dirname = path.dirname(fileURLToPath(import.meta.url))\n\nexport class LanControlServer {\n  private app: Express | null = null;\n  private httpServer: HttpServer | null = null;\n  private wss: WebSocketServer | null = null;\n  private port: number;\n  private config: LanControlConfig;\n  private mainWindow: BrowserWindow | null = null;\n  private clients: Set<WebSocket> = new Set();\n\n  constructor(config: LanControlConfig, mainWindow: BrowserWindow) {\n    this.config = config;\n    this.port = config.port;\n    this.mainWindow = mainWindow;\n  }\n\n  async start(): Promise<{ success: boolean; port?: number; error?: string }> {\n    try {\n      if (this.httpServer) {\n        return { success: false, error: i18n.en.server.alreadyRunning };\n      }\n\n      // Dynamically import dependencies\n      const express = (await import(\"express\")).default;\n      const cors = (await import(\"cors\")).default;\n      const { WebSocketServer } = await import(\"ws\");\n\n      this.app = express();\n      this.app.use(cors());\n      this.app.use(express.json());\n\n      const publicDir = path.join(__dirname, \"../../../public\");\n\n      // Serve static control page\n      this.app.use(express.static(publicDir));\n\n      // Serve control page on root path\n      this.app.get(\"/\", (_req: Request, res: Response) => {\n        res.sendFile(path.join(publicDir, \"control.html\"));\n      });\n\n      // Health check endpoint\n      this.app.get(\"/api/health\", (_req: Request, res: Response) => {\n        res.json({ status: i18n.en.server.healthStatus, version: \"1.0.0\" });\n      });\n\n      // Serve control page\n      this.app.get(\"/control\", (_req: Request, res: Response) => {\n        res.sendFile(path.join(publicDir, \"control.html\"));\n      });\n\n      // Create HTTP server\n      this.httpServer = createServer(this.app);\n\n      // Create WebSocket server\n      this.wss = new WebSocketServer({ server: this.httpServer });\n\n      this.wss.on(\"connection\", (ws: WebSocket, req: IncomingMessage) => {\n        console.log(\n          \"[LAN Control] New client connected from\",\n          req.socket.remoteAddress,\n        );\n\n        let isAuthenticated = false;\n        let authTimeout: NodeJS.Timeout | null = null;\n\n        // Set authentication timeout (30 seconds)\n        authTimeout = setTimeout(() => {\n          if (!isAuthenticated) {\n            ws.send(\n              JSON.stringify({\n                type: LanControlMessageType.ERROR,\n                data: { message: i18n.en.auth.timeout },\n              } as LanControlMessage),\n            );\n            ws.close();\n          }\n        }, 30000);\n\n        ws.on(\"message\", async (message: Buffer) => {\n          try {\n            const msg: LanControlMessage = JSON.parse(message.toString());\n\n            // Handle authentication\n            if (msg.type === LanControlMessageType.AUTH_REQUEST) {\n              if (authTimeout) {\n                clearTimeout(authTimeout);\n                authTimeout = null;\n              }\n\n              const authData = msg.data as AuthRequestData;\n              const authResult = await this.authenticate(authData);\n\n              const response: LanControlMessage = {\n                type: LanControlMessageType.AUTH_RESPONSE,\n                data: {\n                  success: authResult,\n                  message: authResult\n                    ? i18n.en.auth.success\n                    : i18n.en.auth.failed,\n                  deviceInfo: authResult\n                    ? {\n                        name: \"Aonsoku Desktop\",\n                        version: \"0.10.0\",\n                      }\n                    : undefined,\n                } as AuthResponseData,\n              };\n\n              ws.send(JSON.stringify(response));\n\n              if (authResult) {\n                isAuthenticated = true;\n                this.clients.add(ws);\n                console.log(\"[LAN Control] Client authenticated\");\n                // Send initial state\n                this.sendCurrentState(ws);\n              } else {\n                ws.close();\n              }\n              return;\n            }\n\n            // Check authentication for other messages\n            if (!isAuthenticated) {\n              ws.send(\n                JSON.stringify({\n                  type: LanControlMessageType.ERROR,\n                  data: { message: i18n.en.auth.notAuthenticated },\n                } as LanControlMessage),\n              );\n              return;\n            }\n\n            // Handle control messages\n            this.handleControlMessage(msg, ws);\n          } catch (error) {\n            console.error(\"[LAN Control] Error processing message:\", error);\n            ws.send(\n              JSON.stringify({\n                type: LanControlMessageType.ERROR,\n                data: { message: i18n.en.error.invalidMessage },\n              } as LanControlMessage),\n            );\n          }\n        });\n\n        ws.on(\"close\", () => {\n          if (authTimeout) {\n            clearTimeout(authTimeout);\n          }\n          this.clients.delete(ws);\n          console.log(\"[LAN Control] Client disconnected\");\n        });\n\n        ws.on(\"error\", (error) => {\n          console.error(\"[LAN Control] WebSocket error:\", error);\n          this.clients.delete(ws);\n        });\n      });\n\n      // Start server\n      await new Promise<void>((resolve, reject) => {\n        this.httpServer!.listen(this.port, () => {\n          console.log(`[LAN Control] Server started on port ${this.port}`);\n          resolve();\n        }).on(\"error\", (err: NodeJS.ErrnoException) => {\n          if (err.code === \"EADDRINUSE\") {\n            reject(new Error(`Port ${this.port} is already in use`));\n          } else {\n            reject(err);\n          }\n        });\n      });\n\n      return { success: true, port: this.port };\n    } catch (error) {\n      console.error(\"[LAN Control] Failed to start server:\", error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      };\n    }\n  }\n\n  async stop(): Promise<void> {\n    return new Promise((resolve) => {\n      // Close all WebSocket connections\n      for (const client of this.clients) {\n        client.close();\n      }\n      this.clients.clear();\n\n      // Close WebSocket server\n      if (this.wss) {\n        this.wss.close(() => {\n          console.log(\"[LAN Control] WebSocket server closed\");\n        });\n        this.wss = null;\n      }\n\n      // Close HTTP server\n      if (this.httpServer) {\n        this.httpServer.close(() => {\n          console.log(\"[LAN Control] HTTP server closed\");\n          this.httpServer = null;\n          resolve();\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  private async authenticate(authData: AuthRequestData): Promise<boolean> {\n    if (authData.authType === \"lan\") {\n      // Check LAN password (case insensitive)\n      return (\n        authData.password.toUpperCase() === this.config.password.toUpperCase()\n      );\n    } else if (\n      authData.authType === \"navidrome\" &&\n      this.config.allowNavidromeAuth\n    ) {\n      // Check Navidrome credentials\n      if (!authData.username) {\n        return false;\n      }\n      // Send auth request to main window\n      return new Promise((resolve) => {\n        this.mainWindow?.webContents.send(\"lan-control:verify-navidrome-auth\", {\n          username: authData.username,\n          password: authData.password,\n          callback: (result: boolean) => resolve(result),\n        });\n      });\n    }\n    return false;\n  }\n\n  private handleControlMessage(msg: LanControlMessage, ws: WebSocket): void {\n    if (!this.mainWindow) {\n      ws.send(\n        JSON.stringify({\n          type: LanControlMessageType.ERROR,\n          data: { message: i18n.en.error.mainWindowUnavailable },\n        } as LanControlMessage),\n      );\n      return;\n    }\n\n    // Forward control message to renderer\n    this.mainWindow.webContents.send(\"lan-control:message\", msg);\n\n    // Handle state requests immediately\n    switch (msg.type) {\n      case LanControlMessageType.GET_STATE:\n      case LanControlMessageType.GET_CURRENT_SONG:\n      case LanControlMessageType.GET_QUEUE:\n        // These will be responded by the renderer via IPC\n        break;\n    }\n  }\n\n  private sendCurrentState(_ws: WebSocket): void {\n    if (!this.mainWindow) return;\n\n    // Request current state from renderer\n    this.mainWindow.webContents.send(\"lan-control:request-state\");\n  }\n\n  // Public method to broadcast state updates to all clients\n  broadcastStateUpdate(state: PlayerStateData): void {\n    const message: LanControlMessage = {\n      type: LanControlMessageType.STATE_UPDATE,\n      data: state,\n      timestamp: Date.now(),\n    };\n    this.broadcast(message);\n  }\n\n  broadcastCurrentSong(song: CurrentSongData): void {\n    const message: LanControlMessage = {\n      type: LanControlMessageType.CURRENT_SONG_UPDATE,\n      data: song,\n      timestamp: Date.now(),\n    };\n    this.broadcast(message);\n  }\n\n  broadcastQueue(queue: QueueData): void {\n    const message: LanControlMessage = {\n      type: LanControlMessageType.QUEUE_UPDATE,\n      data: queue,\n      timestamp: Date.now(),\n    };\n    this.broadcast(message);\n  }\n\n  private broadcast(message: LanControlMessage): void {\n    const json = JSON.stringify(message);\n    for (const client of this.clients) {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(json);\n      }\n    }\n  }\n\n  updateConfig(config: LanControlConfig): void {\n    this.config = config;\n    this.port = config.port;\n  }\n\n  isRunning(): boolean {\n    return this.httpServer !== null;\n  }\n\n  getPort(): number {\n    return this.port;\n  }\n}\n"],"names":["BINARY_TYPES","hasBlob","Blob","push","constants","EMPTY_BUFFER","Buffer","alloc","GUID","kForOnEventAttribute","Symbol","kListener","kStatusCode","kWebSocket","NOOP","require$$0","FastBuffer","species","_mask","source","mask","output","offset","length","i","_unmask","buffer","bufferUtilModule","exports","concat","list","totalLength","target","allocUnsafe","buf","set","byteOffset","toArrayBuffer","byteLength","slice","toBuffer","data","readOnly","isBuffer","ArrayBuffer","isView","from","unmask","process","WS_NO_BUFFER_UTIL","bufferUtil","require$$1","e","zlib","Limiter","kDone","kRun","limiter","constructor","concurrency","this","pending","Infinity","jobs","add","job","shift","require$$2","require$$3","TRAILER","kPerMessageDeflate","kTotalLength","kCallback","kBuffers","kError","zlibLimiter","deflateOnData","chunk","inflateOnData","_maxPayload","RangeError","code","removeListener","reset","inflateOnError","err","_inflate","permessageDeflate","options","isServer","maxPayload","_options","_threshold","threshold","_isServer","_deflate","params","concurrencyLimit","extensionName","offer","serverNoContextTakeover","server_no_context_takeover","clientNoContextTakeover","client_no_context_takeover","serverMaxWindowBits","server_max_window_bits","clientMaxWindowBits","client_max_window_bits","accept","configurations","normalizeParams","acceptAsServer","acceptAsClient","cleanup","close","callback","Error","offers","opts","accepted","find","response","forEach","Object","keys","key","value","num","Number","isInteger","TypeError","decompress","fin","done","_decompress","result","compress","_compress","endpoint","windowBits","Z_DEFAULT_WINDOWBITS","createInflateRaw","zlibInflateOptions","on","write","flush","_readableState","endEmitted","createDeflateRaw","zlibDeflateOptions","Z_SYNC_FLUSH","isUtf8","_isValidUTF8","len","validationModule","isBlob","arrayBuffer","type","stream","toStringTag","isValidStatusCode","isValidUTF8","tokenChars","WS_NO_UTF_8_VALIDATE","Writable","PerMessageDeflate","require$$4","receiver","super","_allowSynchronousEvents","allowSynchronousEvents","_binaryType","binaryType","_extensions","extensions","_skipUTF8Validation","skipUTF8Validation","_bufferedBytes","_buffers","_compressed","_payloadLength","_fragmented","_masked","_fin","_opcode","_totalPayloadLength","_messageLength","_fragments","_errored","_loop","_state","_write","encoding","cb","startLoop","consume","n","dst","Uint8Array","getInfo","getPayloadLength16","getPayloadLength64","getMask","getData","createError","compressed","haveLength","readUInt16BE","readUInt32BE","Math","pow","controlMessage","dataMessage","error","messageLength","fragments","emit","setImmediate","end","ErrorCtor","message","prefix","statusCode","errorCode","captureStackTrace","Duplex","randomFillSync","applyMask","require$$5","kByteLength","maskBuffer","RANDOM_POOL_SIZE","randomPool","randomPoolPointer","Sender","socket","generateMask","_generateMask","_maskBuffer","_socket","_firstFragment","_queue","onerror","frame","dataLength","merge","skipMasking","payloadLength","opcode","rsv1","writeUInt16BE","writeUIntBE","enqueue","dispatch","sendFrame","ping","size","getBlobData","pong","send","perMessageDeflate","binary","blob","then","destroyed","nextTick","callCallbacks","dequeue","catch","onError","_","Reflect","apply","cork","uncork","sender","dest","name","elem","extension","format","map","Array","isArray","k","values","v","join","parse","header","create","paramName","mustUnescape","isEscaping","inQuotes","start","charCodeAt","SyntaxError","replace","token","EventEmitter","https","http","net","tls","randomBytes","createHash","Readable","require$$6","URL","require$$7","require$$8","Receiver","require$$9","require$$10","require$$11","require$$12","EventTarget","addEventListener","removeEventListener","kCode","kData","kMessage","kReason","kTarget","kType","kWasClean","Event","defineProperty","prototype","enumerable","CloseEvent","reason","wasClean","ErrorEvent","MessageEvent","handler","listener","listeners","wrapper","isBinary","event","toString","callListener","_closeFrameReceived","_closeFrameSent","once","thisArg","handleEvent","call","eventTarget","require$$13","require$$14","require$$15","kAborted","protocolVersions","readyStates","subprotocolRegex","WebSocket","address","protocols","_closeCode","_closeMessage","_closeTimer","_errorEmitted","_paused","_protocol","_readyState","CONNECTING","_receiver","_sender","_bufferedAmount","_redirects","initAsClient","_autoPong","autoPong","includes","bufferedAmount","_writableState","isPaused","onclose","onopen","onmessage","protocol","readyState","url","_url","setSocket","head","receiverOnConclude","receiverOnDrain","receiverOnError","receiverOnMessage","receiverOnPing","receiverOnPong","senderOnError","setTimeout","setNoDelay","unshift","socketOnClose","socketOnData","socketOnEnd","socketOnError","OPEN","emitClose","CLOSED","removeAllListeners","msg","abortHandshake","_req","CLOSING","errorEmitted","setCloseTimer","pause","sendAfterClose","resume","needDrain","terminate","destroy","websocket","protocolVersion","followRedirects","maxRedirects","socketPath","hostname","timeout","method","host","path","port","parsedUrl","href","isSecure","isIpcUrl","invalidUrlMessage","pathname","hash","emitErrorAndClose","defaultPort","request","protocolSet","Set","req","createConnection","tlsConnect","netConnect","startsWith","headers","Connection","Upgrade","search","handshakeTimeout","test","has","origin","Origin","username","password","auth","parts","split","_originalIpc","_originalSecure","_originalHostOrSocketPath","entries","toLowerCase","listenerCount","isSameHost","authorization","cookie","res","location","addr","abort","upgrade","digest","update","serverProt","protError","secWebSocketExtensions","extensionNames","finishRequest","connect","servername","isIP","setHeader","bind","receiverOnFinish","read","clearTimeout","finished","indexOf","property","get","duplexOnEnd","duplexOnError","ws","terminateOnDestroy","duplex","autoDestroy","objectMode","writableObjectMode","_destroy","called","_final","_read","subprotocol","keyRegex","server","STATUS_CODES","h","abortHandshakeOrEmitwsClientError","websocketServer","handleProtocols","clientTracking","verifyClient","noServer","backlog","_server","createServer","body","writeHead","listen","emitConnection","_removeListeners","addListeners","listening","handleUpgrade","clients","_shouldEmitClose","shouldHandle","index","version","secWebSocketProtocol","info","secure","authorized","encrypted","verified","completeUpgrade","readable","writable","next","delete","LanControlMessageType","i18n","alreadyRunning","healthStatus","success","failed","notAuthenticated","invalidMessage","mainWindowUnavailable","notFound","settings","desktop","lanControl","enable","allowNavidromeAuth","app","httpServer","wss","config","mainWindow","express","import","default","cors","WebSocketServer","use","json","publicDir","__dirname","static","sendFile","status","console","log","remoteAddress","isAuthenticated","authTimeout","JSON","stringify","ERROR","async","AUTH_REQUEST","authData","authResult","authenticate","AUTH_RESPONSE","deviceInfo","sendCurrentState","handleControlMessage","Promise","resolve","reject","stop","client","clear","authType","toUpperCase","webContents","GET_STATE","GET_CURRENT_SONG","GET_QUEUE","_ws","broadcastStateUpdate","state","STATE_UPDATE","timestamp","Date","now","broadcast","broadcastCurrentSong","song","CURRENT_SONG_UPDATE","broadcastQueue","queue","QUEUE_UPDATE","updateConfig","isRunning","getPort"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12]}