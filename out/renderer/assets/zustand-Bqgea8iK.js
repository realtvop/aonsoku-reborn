import{p as e}from"./immer-Dwi4ZIhD.js";import{a as t}from"./react-BohqOKG4.js";import{u as n}from"./use-sync-external-store-C4iHanJs.js";const r={BASE_URL:"./",DEV:!1,MODE:"production",PROD:!0,SSR:!1},o=new Map,s=e=>{const t=o.get(e);return t?Object.fromEntries(Object.entries(t.stores).map(([e,t])=>[e,t.getState()])):{}},i=(e,t={})=>(n,i,c)=>{const{enabled:l,anonymousActionType:u,store:d,...f}=t;let p;try{p=(null!=l?l:"production"!==(r?"production":void 0))&&window.__REDUX_DEVTOOLS_EXTENSION__}catch(h){}if(!p)return"production"!==(r?"production":void 0)&&l&&console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension"),e(n,i,c);const{connection:v,...g}=((e,t,n)=>{if(void 0===e)return{type:"untracked",connection:t.connect(n)};const r=o.get(n.name);if(r)return{type:"tracked",store:e,...r};const s={connection:t.connect(n),stores:{}};return o.set(n.name,s),{type:"tracked",store:e,...s}})(d,p,f);let m=!0;c.setState=(e,t,r)=>{const o=n(e,t);if(!m)return o;const a=void 0===r?{type:u||"anonymous"}:"string"==typeof r?{type:r}:r;return void 0===d?(null==v||v.send(a,i()),o):(null==v||v.send({...a,type:`${d}/${a.type}`},{...s(f.name),[d]:c.getState()}),o)};const S=(...e)=>{const t=m;m=!1,n(...e),m=t},y=e(c.setState,i,c);if("untracked"===g.type?null==v||v.init(y):(g.stores[g.store]=c,null==v||v.init(Object.fromEntries(Object.entries(g.stores).map(([e,t])=>[e,e===g.store?y:t.getState()])))),c.dispatchFromDevtools&&"function"==typeof c.dispatch){let e=!1;const t=c.dispatch;c.dispatch=(...n)=>{"production"===(r?"production":void 0)||"__setState"!==n[0].type||e||(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),e=!0),t(...n)}}return v.subscribe(e=>{var t;switch(e.type){case"ACTION":return"string"!=typeof e.payload?void console.error("[zustand devtools middleware] Unsupported action format"):a(e.payload,e=>{if("__setState"===e.type){if(void 0===d)return void S(e.state);1!==Object.keys(e.state).length&&console.error('\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using \'store\' option in devtools(), the \'state\' should have only one key, which is a value of \'store\' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }\n                    ');const t=e.state[d];if(null==t)return;return void(JSON.stringify(c.getState())!==JSON.stringify(t)&&S(t))}c.dispatchFromDevtools&&"function"==typeof c.dispatch&&c.dispatch(e)});case"DISPATCH":switch(e.payload.type){case"RESET":return S(y),void 0===d?null==v?void 0:v.init(c.getState()):null==v?void 0:v.init(s(f.name));case"COMMIT":return void 0===d?void(null==v||v.init(c.getState())):null==v?void 0:v.init(s(f.name));case"ROLLBACK":return a(e.state,e=>{if(void 0===d)return S(e),void(null==v||v.init(c.getState()));S(e[d]),null==v||v.init(s(f.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return a(e.state,e=>{void 0!==d?JSON.stringify(c.getState())!==JSON.stringify(e[d])&&S(e[d]):S(e)});case"IMPORT_STATE":{const{nextLiftedState:n}=e.payload,r=null==(t=n.computedStates.slice(-1)[0])?void 0:t.state;if(!r)return;return S(void 0===d?r:r[d]),void(null==v||v.send(null,n))}case"PAUSE_RECORDING":return m=!m}return}}),y},a=(e,t)=>{let n;try{n=JSON.parse(e)}catch(r){console.error("[zustand devtools middleware] Could not parse the received json",r)}void 0!==n&&t(n)},c=e=>(t,n,r)=>{const o=r.subscribe;r.subscribe=(e,t,n)=>{let s=e;if(t){const o=(null==n?void 0:n.equalityFn)||Object.is;let i=e(r.getState());s=n=>{const r=e(n);if(!o(i,r)){const e=i;t(i=r,e)}},(null==n?void 0:n.fireImmediately)&&t(i,i)}return o(s)};return e(t,n,r)};function l(e,t){let n;try{n=e()}catch(r){return}return{getItem:e=>{var t;const r=e=>null===e?null:JSON.parse(e,void 0),o=null!=(t=n.getItem(e))?t:null;return o instanceof Promise?o.then(r):r(o)},setItem:(e,t)=>n.setItem(e,JSON.stringify(t,void 0)),removeItem:e=>n.removeItem(e)}}const u=e=>t=>{try{const n=e(t);return n instanceof Promise?n:{then:e=>u(e)(n),catch(e){return this}}}catch(n){return{then(e){return this},catch:e=>u(e)(n)}}},d=(e,t)=>"getStorage"in t||"serialize"in t||"deserialize"in t?("production"!==(r?"production":void 0)&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),((e,t)=>(n,r,o)=>{let s={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:e=>e,version:0,merge:(e,t)=>({...t,...e}),...t},i=!1;const a=new Set,c=new Set;let l;try{l=s.getStorage()}catch(S){}if(!l)return e((...e)=>{console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),n(...e)},r,o);const d=u(s.serialize),f=()=>{const e=s.partialize({...r()});let t;const n=d({state:e,version:s.version}).then(e=>l.setItem(s.name,e)).catch(e=>{t=e});if(t)throw t;return n},p=o.setState;o.setState=(e,t)=>{p(e,t),f()};const v=e((...e)=>{n(...e),f()},r,o);let g;const m=()=>{var e;if(!l)return;i=!1,a.forEach(e=>e(r()));const t=(null==(e=s.onRehydrateStorage)?void 0:e.call(s,r()))||void 0;return u(l.getItem.bind(l))(s.name).then(e=>{if(e)return s.deserialize(e)}).then(e=>{if(e){if("number"!=typeof e.version||e.version===s.version)return e.state;if(s.migrate)return s.migrate(e.state,e.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}}).then(e=>{var t;return g=s.merge(e,null!=(t=r())?t:v),n(g,!0),f()}).then(()=>{null==t||t(g,void 0),i=!0,c.forEach(e=>e(g))}).catch(e=>{null==t||t(void 0,e)})};return o.persist={setOptions:e=>{s={...s,...e},e.getStorage&&(l=e.getStorage())},clearStorage:()=>{null==l||l.removeItem(s.name)},getOptions:()=>s,rehydrate:()=>m(),hasHydrated:()=>i,onHydrate:e=>(a.add(e),()=>{a.delete(e)}),onFinishHydration:e=>(c.add(e),()=>{c.delete(e)})},m(),g||v})(e,t)):((e,t)=>(n,r,o)=>{let s={storage:l(()=>localStorage),partialize:e=>e,version:0,merge:(e,t)=>({...t,...e}),...t},i=!1;const a=new Set,c=new Set;let d=s.storage;if(!d)return e((...e)=>{console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),n(...e)},r,o);const f=()=>{const e=s.partialize({...r()});return d.setItem(s.name,{state:e,version:s.version})},p=o.setState;o.setState=(e,t)=>{p(e,t),f()};const v=e((...e)=>{n(...e),f()},r,o);let g;o.getInitialState=()=>v;const m=()=>{var e,t;if(!d)return;i=!1,a.forEach(e=>{var t;return e(null!=(t=r())?t:v)});const o=(null==(t=s.onRehydrateStorage)?void 0:t.call(s,null!=(e=r())?e:v))||void 0;return u(d.getItem.bind(d))(s.name).then(e=>{if(e){if("number"!=typeof e.version||e.version===s.version)return[!1,e.state];if(s.migrate)return[!0,s.migrate(e.state,e.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}return[!1,void 0]}).then(e=>{var t;const[o,i]=e;if(g=s.merge(i,null!=(t=r())?t:v),n(g,!0),o)return f()}).then(()=>{null==o||o(g,void 0),g=r(),i=!0,c.forEach(e=>e(g))}).catch(e=>{null==o||o(void 0,e)})};return o.persist={setOptions:e=>{s={...s,...e},e.storage&&(d=e.storage)},clearStorage:()=>{null==d||d.removeItem(s.name)},getOptions:()=>s,rehydrate:()=>m(),hasHydrated:()=>i,onHydrate:e=>(a.add(e),()=>{a.delete(e)}),onFinishHydration:e=>(c.add(e),()=>{c.delete(e)})},s.skipHydration||m(),g||v})(e,t),f=t=>(n,r,o)=>(o.setState=(t,r,...o)=>{const s="function"==typeof t?e(t):t;return n(s,r,...o)},t(o.setState,r,o));function p(e,t){if(Object.is(e,t))return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;if(e instanceof Map&&t instanceof Map){if(e.size!==t.size)return!1;for(const[n,r]of e)if(!Object.is(r,t.get(n)))return!1;return!0}if(e instanceof Set&&t instanceof Set){if(e.size!==t.size)return!1;for(const n of e)if(!t.has(n))return!1;return!0}const n=Object.keys(e);if(n.length!==Object.keys(t).length)return!1;for(const r of n)if(!Object.prototype.hasOwnProperty.call(t,r)||!Object.is(e[r],t[r]))return!1;return!0}const v={},g=e=>{let t;const n=new Set,r=(e,r)=>{const o="function"==typeof e?e(t):e;if(!Object.is(o,t)){const e=t;t=(null!=r?r:"object"!=typeof o||null===o)?o:Object.assign({},t,o),n.forEach(n=>n(t,e))}},o=()=>t,s={setState:r,getState:o,getInitialState:()=>i,subscribe:e=>(n.add(e),()=>n.delete(e)),destroy:()=>{"production"!==(v?"production":void 0)&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),n.clear()}},i=t=e(r,o,s);return s},{useDebugValue:m}=t,{useSyncExternalStoreWithSelector:S}=n,y=e=>e;const h=(e,t)=>{const n=(e=>e?g(e):g)(e),r=(e,r=t)=>function(e,t=y,n){const r=S(e.subscribe,e.getState,e.getServerState||e.getInitialState,t,n);return m(r),r}(n,e,r);return Object.assign(r,n),r},b=(e,t)=>h;export{p as a,b as c,i as d,f as i,d as p,c as s};
